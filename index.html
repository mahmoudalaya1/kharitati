
import 'dart:async';
import 'dart:convert';
import 'dart:io';

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:geolocator/geolocator.dart';
import 'package:google_api_availability/google_api_availability.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import 'package:http/http.dart' as http;
import 'package:image_picker/image_picker.dart';
import 'package:provider/provider.dart';
import 'package:url_launcher/url_launcher.dart';

import '../../core/config/google_maps_config.dart';
import '../../l10n/app_localizations.dart';
import '../../models/property_model.dart';
import '../../providers/auth_provider.dart';
import '../../providers/map_provider.dart';
import '../../providers/property_provider.dart';
import '../../providers/trial_provider.dart';
import '../../routes/app_routes.dart';
import '../../services/imgbb_service.dart';
import '../../services/location_service.dart';
import '../../services/map_service.dart';
import '../../services/user_profile_service.dart';
import '../../widgets/map_marker_widget.dart';
import '../../widgets/splash_screen.dart';
import '../property_details/property_details_sheet.dart';

class MapScreen extends StatefulWidget {
  const MapScreen({super.key});

  @override
  State<MapScreen> createState() => _MapScreenState();
}

enum _MapScreenStage { loading, error, ready }

class _MapScreenState extends State<MapScreen> {
  static const CameraPosition _fallbackCamera = CameraPosition(
    target: LatLng(30.0444, 31.2357),
    zoom: GoogleMapsConfig.initialZoom,
  );

  final MapService _mapService = MapService();
  final LocationService _locationService = LocationService();
  final UserProfileService _userProfileService = UserProfileService();

  late final MapProvider _mapProvider;
  late final PropertyProvider _propertyProvider;
  late final _MapScreenController _controller;

  OverlayEntry? _notificationEntry;

  @override
  void initState() {
    super.initState();
    _mapProvider = context.read<MapProvider>();
    _propertyProvider = context.read<PropertyProvider>();
    _controller = _MapScreenController(
      mapProvider: _mapProvider,
      propertyProvider: _propertyProvider,
      userProfileService: _userProfileService,
      onNearbyNotification: _showNearbyNotification,
      isMounted: () => mounted,
    );
    _controller.attachListeners();
    _controller.startNearbyTimer();
    _initializeAsync();

    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (!mounted) return;
      _controller.refreshFromProviders();
    });
  }

  Future<void> _initializeAsync() async {
    await _controller.checkPlayServicesAvailability();
  }

  @override
  void dispose() {
    _notificationEntry?.remove();
    _notificationEntry = null;
    _controller.dispose();
    super.dispose();
  }

  _MapScreenStage _resolveStage(
    MapProvider mapProvider,
    PropertyProvider propertyProvider,
  ) {
    if (_controller.checkingPlayServices) {
      return _MapScreenStage.loading;
    }
    if (!_controller.playServicesAvailable) {
      return _MapScreenStage.error;
    }
    if (mapProvider.isLoading || propertyProvider.isLoading) {
      return _MapScreenStage.loading;
    }
    return _MapScreenStage.ready;
  }

  Widget _buildLoadingScaffold() {
    return const Scaffold(
      body: Center(child: CircularProgressIndicator()),
    );
  }

  Widget _buildMapRenderError(BuildContext context, {String? label}) {
    final colorScheme = Theme.of(context).colorScheme;
    return Scaffold(
      body: Center(
        child: Padding(
          padding: const EdgeInsets.all(24),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(Icons.error_outline, size: 40, color: colorScheme.error),
              const SizedBox(height: 12),
              Text(label ?? 'Unable to render the map right now.'),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildOverlayError(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    return Material(
      color: Colors.transparent,
      child: Center(
        child: Container(
          margin: const EdgeInsets.all(24),
          padding: const EdgeInsets.all(16),
          decoration: BoxDecoration(
            color: colorScheme.surface,
            borderRadius: BorderRadius.circular(16),
            border: Border.all(color: colorScheme.error),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withOpacity(0.2),
                blurRadius: 16,
                offset: const Offset(0, 8),
              ),
            ],
          ),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(Icons.warning_amber, color: colorScheme.error),
              const SizedBox(width: 12),
              const Flexible(child: Text('Map controls failed to render.')),
            ],
          ),
        ),
      ),
    );
  }

  Widget _safeBuildMap(BuildContext context, Widget Function() builder) {
    try {
      return builder();
    } catch (_) {
      return _buildMapRenderError(context);
    }
  }

  Widget _safeBuildOverlays(BuildContext context, Widget Function() builder) {
    try {
      return builder();
    } catch (_) {
      return _buildOverlayError(context);
    }
  }

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: _controller,
      builder: (context, _) {
        final mapProvider = context.watch<MapProvider>();
        final propertyProvider = context.watch<PropertyProvider>();
        final trialProvider = context.watch<TrialProvider>();

        final stage = _resolveStage(mapProvider, propertyProvider);
        if (stage == _MapScreenStage.loading) {
          if (_controller.checkingPlayServices) {
            return const SplashScreen();
          }
          return _buildLoadingScaffold();
        }

        if (stage == _MapScreenStage.error) {
          return _buildPlayServicesError(context);
        }

        final initialCamera = mapProvider.cameraPosition ?? _fallbackCamera;
        final locationEnabled = mapProvider.locationPermissionGranted;

        final mapLayer = _safeBuildMap(
          context,
          () => _MapRenderer(
            initialCamera: initialCamera,
            mapType: mapProvider.mapType,
            trafficEnabled: mapProvider.trafficEnabled,
            buildingsEnabled: mapProvider.buildingsEnabled,
            myLocationEnabled: locationEnabled,
            markers: _controller.mapReady ? _controller.markers : const <Marker>{},
            onMapCreated: _controller.onMapCreated,
            onCameraMove: (position) {
              _controller.onCameraMove(position);
            },
            onCameraIdle: _controller.onCameraIdle,
          ),
        );

        final overlayLayer = _safeBuildOverlays(
          context,
          () => _MapOverlays(
            controller: _controller,
            mapProvider: mapProvider,
            propertyProvider: propertyProvider,
            trialProvider: trialProvider,
            onSearch: _openSearch,
            onShowLayers: _showLayersSheet,
            onShowOverflowMenu: _showOverflowMenu,
            onGoToMyLocation: _goToMyLocation,
            onSellHere: _handleSellHere,
            onShowTrialRequired: _showTrialRequiredDialog,
            onOpenDetailsSheet: _openDetailsSheet,
          ),
        );

        return Scaffold(
          body: Stack(
            children: [
              Positioned.fill(child: mapLayer),
              Positioned.fill(child: overlayLayer),
            ],
          ),
        );
      },
    );
  }

  Widget _buildPlayServicesError(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final l10n = AppLocalizations.of(context);

    return Scaffold(
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(24),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(Icons.map_outlined, size: 72, color: colorScheme.error),
              const SizedBox(height: 16),
              Text(
                l10n?.error ?? 'Map Error',
                style: theme.textTheme.headlineSmall?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 12),
              Text(
                _controller.playServicesError ??
                    'Google Play Services is required to display the map.',
                style: theme.textTheme.bodyMedium?.copyWith(
                  color: colorScheme.onSurface.withOpacity(0.75),
                ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 24),
              if (_controller.canUpdatePlayServices)
                ElevatedButton.icon(
                  onPressed: _openPlayServicesStore,
                  icon: const Icon(Icons.download),
                  label: const Text('Update Google Play Services'),
                ),
              const SizedBox(height: 12),
              TextButton(
                onPressed: _controller.checkPlayServicesAvailability,
                child: Text(l10n?.retry ?? 'Retry'),
              ),
            ],
          ),
        ),
      ),
    );
  }
  Future<void> _openSearch() async {
    final l10n = AppLocalizations.of(context)!;
    if (GoogleMapsConfig.apiKey.trim().isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(l10n.searchUnavailable)),
      );
      return;
    }

    final selection = await _showSearchSheet();
    if (!mounted || selection == null) return;

    final location = await _fetchPlaceLatLng(selection.placeId);
    if (!mounted || location == null) return;

    await _controller.safeAnimateCamera(
      CameraUpdate.newCameraPosition(
        CameraPosition(target: location, zoom: 17.5),
      ),
    );

    if (!mounted) return;
    _controller.setSearchLabel(selection.description);
    await _controller.updateSearchMarker(location, selection.description);
  }

  Future<_PlaceSuggestion?> _showSearchSheet() async {
    final l10n = AppLocalizations.of(context)!;
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final controller = TextEditingController(text: _controller.searchLabel);
    final focusNode = FocusNode();
    final localeCode = Localizations.localeOf(context).languageCode;
    final currentLocation = context.read<MapProvider>().currentLocation;

    Timer? debounce;
    List<_PlaceSuggestion> results = [];
    bool isLoading = false;

    Future<void> runSearch(
      String query,
      void Function(void Function()) setState,
    ) async {
      if (query.trim().isEmpty) {
        setState(() {
          results = [];
          isLoading = false;
        });
        return;
      }
      setState(() {
        isLoading = true;
      });
      final fetched = await _searchPlaces(
        query: query,
        language: localeCode,
        proximity: currentLocation,
      );
      if (!mounted) return;
      setState(() {
        results = fetched;
        isLoading = false;
      });
    }

    final selection = await showModalBottomSheet<_PlaceSuggestion>(
      context: context,
      isScrollControlled: true,
      backgroundColor: colorScheme.surface,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(24)),
      ),
      builder: (context) {
        return StatefulBuilder(
          builder: (context, setState) {
            return Padding(
              padding: EdgeInsets.only(
                left: 16,
                right: 16,
                top: 16,
                bottom: MediaQuery.of(context).viewInsets.bottom + 16,
              ),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Container(
                    width: 44,
                    height: 4,
                    decoration: BoxDecoration(
                      color: colorScheme.onSurface.withOpacity(0.3),
                      borderRadius: BorderRadius.circular(2),
                    ),
                  ),
                  const SizedBox(height: 12),
                  TextField(
                    controller: controller,
                    focusNode: focusNode,
                    decoration: InputDecoration(
                      hintText: l10n.searchPlaces,
                      prefixIcon: const Icon(Icons.search),
                      suffixIcon: controller.text.isNotEmpty
                          ? IconButton(
                              icon: const Icon(Icons.close),
                              onPressed: () {
                                controller.clear();
                                setState(() {
                                  results = [];
                                  isLoading = false;
                                });
                              },
                            )
                          : null,
                    ),
                    onChanged: (value) {
                      debounce?.cancel();
                      debounce = Timer(
                        const Duration(milliseconds: 350),
                        () => runSearch(value, setState),
                      );
                    },
                    onSubmitted: (value) => runSearch(value, setState),
                  ),
                  const SizedBox(height: 12),
                  if (isLoading)
                    const Padding(
                      padding: EdgeInsets.all(12),
                      child: CircularProgressIndicator(),
                    )
                  else if (results.isEmpty)
                    Padding(
                      padding: const EdgeInsets.symmetric(vertical: 12),
                      child: Text(
                        l10n.searchHint,
                        style: theme.textTheme.bodySmall?.copyWith(
                          color: colorScheme.onSurface.withOpacity(0.7),
                        ),
                      ),
                    )
                  else
                    Flexible(
                      child: ListView.separated(
                        shrinkWrap: true,
                        itemCount: results.length,
                        separatorBuilder: (_, _) => const Divider(height: 1),
                        itemBuilder: (context, index) {
                          final item = results[index];
                          return ListTile(
                            title: Text(item.description),
                            onTap: () => Navigator.pop(context, item),
                          );
                        },
                      ),
                    ),
                ],
              ),
            );
          },
        );
      },
    );

    debounce?.cancel();
    focusNode.dispose();
    controller.dispose();
    return selection;
  }

  Future<List<_PlaceSuggestion>> _searchPlaces({
    required String query,
    required String language,
    LatLng? proximity,
  }) async {
    final apiKey = GoogleMapsConfig.apiKey;
    if (apiKey.trim().isEmpty) return [];

    try {
      final params = <String, String>{
        'input': query,
        'key': apiKey,
        'language': language,
      };
      if (proximity != null) {
        params['location'] = '${proximity.latitude},${proximity.longitude}';
        params['radius'] = '50000';
      }
      final uri = Uri.https(
        'maps.googleapis.com',
        '/maps/api/place/autocomplete/json',
        params,
      );
      final response =
          await http.get(uri).timeout(const Duration(seconds: 10));
      if (response.statusCode != 200) return [];

      final decoded = jsonDecode(response.body) as Map<String, dynamic>;
      final predictions = decoded['predictions'] as List<dynamic>? ?? [];
      final results = <_PlaceSuggestion>[];
      for (final item in predictions) {
        final entry = item as Map<String, dynamic>;
        final description = entry['description']?.toString();
        final placeId = entry['place_id']?.toString();
        if (description == null || placeId == null) continue;
        results.add(
          _PlaceSuggestion(description: description, placeId: placeId),
        );
      }
      return results;
    } catch (_) {
      return [];
    }
  }

  Future<LatLng?> _fetchPlaceLatLng(String placeId) async {
    if (placeId.isEmpty) return null;
    try {
      final uri = Uri.https(
        'maps.googleapis.com',
        '/maps/api/place/details/json',
        {
          'place_id': placeId,
          'key': GoogleMapsConfig.apiKey,
        },
      );
      final response =
          await http.get(uri).timeout(const Duration(seconds: 10));
      if (response.statusCode != 200) return null;
      final decoded = jsonDecode(response.body) as Map<String, dynamic>;
      final result = decoded['result'] as Map<String, dynamic>?;
      final geometry = result?['geometry'] as Map<String, dynamic>?;
      final location = geometry?['location'] as Map<String, dynamic>?;
      final lat = (location?['lat'] as num?)?.toDouble();
      final lng = (location?['lng'] as num?)?.toDouble();
      if (lat == null || lng == null) return null;
      return LatLng(lat, lng);
    } catch (_) {
      return null;
    }
  }

  void _openDetailsSheet(PropertyModel property) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Theme.of(context).colorScheme.surface,
      builder: (_) => PropertyDetailsSheet(property: property),
    );
  }

  void _showOverflowMenu() {
    final colorScheme = Theme.of(context).colorScheme;
    final l10n = AppLocalizations.of(context)!;
    showModalBottomSheet(
      context: context,
      backgroundColor: colorScheme.surface,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
      ),
      builder: (context) {
        return SafeArea(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              ListTile(
                leading: Icon(Icons.person, color: colorScheme.primary),
                title: Text(l10n.profile),
                onTap: () {
                  Navigator.pop(context);
                  Navigator.pushNamed(context, AppRoutes.profile);
                },
              ),
              ListTile(
                leading: Icon(Icons.logout, color: colorScheme.error),
                title: Text(
                  l10n.signOut,
                  style: TextStyle(color: colorScheme.error),
                ),
                onTap: () async {
                  Navigator.pop(context);
                  final authProvider = context.read<AuthProvider>();
                  await authProvider.signOut();
                  if (!context.mounted) return;
                  Navigator.pushNamedAndRemoveUntil(
                    context,
                    AppRoutes.login,
                    (route) => false,
                  );
                },
              ),
              const SizedBox(height: 8),
            ],
          ),
        );
      },
    );
  }

  void _showLayersSheet() {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final l10n = AppLocalizations.of(context)!;

    showModalBottomSheet(
      context: context,
      backgroundColor: colorScheme.surface,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
      ),
      builder: (context) {
        return Consumer<MapProvider>(
          builder: (context, mapProvider, __) {
            return SafeArea(
              child: Padding(
                padding: const EdgeInsets.symmetric(vertical: 12),
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    ListTile(
                      title: Text(
                        l10n.layers,
                        style: theme.textTheme.titleMedium?.copyWith(
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),
                    RadioGroup<MapType>(
                      groupValue: mapProvider.mapType,
                      onChanged: (value) {
                        if (value == null) return;
                        mapProvider.updateMapType(value);
                      },
                      child: Column(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          RadioListTile<MapType>(
                            value: MapType.normal,
                            title: Text(l10n.mapTypeNormal),
                          ),
                          RadioListTile<MapType>(
                            value: MapType.satellite,
                            title: Text(l10n.mapTypeSatellite),
                          ),
                          RadioListTile<MapType>(
                            value: MapType.terrain,
                            title: Text(l10n.mapTypeTerrain),
                          ),
                        ],
                      ),
                    ),
                    SwitchListTile(
                      value: mapProvider.trafficEnabled,
                      onChanged: mapProvider.updateTrafficEnabled,
                      title: Text(l10n.trafficLayer),
                    ),
                    SwitchListTile(
                      value: mapProvider.buildingsEnabled,
                      onChanged: mapProvider.updateBuildingsEnabled,
                      title: Text(l10n.buildingsLayer),
                    ),
                  ],
                ),
              ),
            );
          },
        );
      },
    );
  }

  void _showTrialRequiredDialog() {
    final l10n = AppLocalizations.of(context)!;
    final colorScheme = Theme.of(context).colorScheme;

    showDialog<void>(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: colorScheme.surface,
        title: Text(l10n.trialRequiredTitle),
        content: Text(l10n.trialRequiredMessage),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: Text(
              l10n.ok,
              style: TextStyle(color: colorScheme.primary),
            ),
          ),
        ],
      ),
    );
  }

  Future<void> _handleSellHere() async {
    final trialProvider = context.read<TrialProvider>();
    if (!trialProvider.isTrialActive) {
      _showTrialRequiredDialog();
      return;
    }

    final position = await _mapService.getCurrentLocation();
    if (position == null) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(AppLocalizations.of(context)!.locationPermissionDenied),
        ),
      );
      return;
    }

    final location = LatLng(position.latitude, position.longitude);
    final address = await _locationService.getAddressFromLatLng(location);
    if (!mounted) return;

    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Theme.of(context).colorScheme.surface,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(24)),
      ),
      builder: (_) => SellHereSheet(
        location: location,
        address: address,
      ),
    );
  }

  Future<void> _goToMyLocation() async {
    final colorScheme = Theme.of(context).colorScheme;
    final l10n = AppLocalizations.of(context)!;

    final serviceEnabled = await Geolocator.isLocationServiceEnabled();
    if (!serviceEnabled) {
      _showLocationDialog(
        title: l10n.locationDisabledTitle,
        message: l10n.locationDisabledMessage,
      );
      return;
    }

    LocationPermission permission = await Geolocator.checkPermission();
    if (permission == LocationPermission.denied) {
      permission = await Geolocator.requestPermission();
    }

    if (permission == LocationPermission.denied) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(l10n.locationPermissionDenied),
          backgroundColor: colorScheme.error,
        ),
      );
      return;
    }

    if (permission == LocationPermission.deniedForever) {
      _showLocationDialog(
        title: l10n.locationPermissionTitle,
        message: l10n.locationPermissionMessage,
        showSettings: true,
      );
      return;
    }

    final position = await Geolocator.getCurrentPosition(
      locationSettings: const LocationSettings(
        accuracy: LocationAccuracy.high,
      ),
    );

    final target = LatLng(position.latitude, position.longitude);
    final bearing = position.heading.isNaN ? 0.0 : position.heading;

    await _controller.safeAnimateCamera(
      CameraUpdate.newCameraPosition(
        CameraPosition(
          target: target,
          zoom: 18,
          bearing: bearing,
        ),
      ),
    );
  }

  Future<void> _showLocationDialog({
    required String title,
    required String message,
    bool showSettings = false,
  }) async {
    if (!mounted) return;
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final l10n = AppLocalizations.of(context)!;

    await showDialog<void>(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(title),
        content: Text(message),
        backgroundColor: colorScheme.surface,
        actions: [
          if (showSettings)
            TextButton(
              onPressed: () async {
                Navigator.pop(context);
                await Geolocator.openAppSettings();
              },
              child: Text(l10n.openSettings),
            ),
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: Text(
              l10n.ok,
              style: theme.textTheme.bodyMedium?.copyWith(
                color: colorScheme.primary,
              ),
            ),
          ),
        ],
      ),
    );
  }

  Future<void> _openPlayServicesStore() async {
    final marketUri = Uri.parse('market://details?id=com.google.android.gms');
    final webUri = Uri.parse(
      'https://play.google.com/store/apps/details?id=com.google.android.gms',
    );
    if (await canLaunchUrl(marketUri)) {
      await launchUrl(marketUri);
      return;
    }
    if (await canLaunchUrl(webUri)) {
      await launchUrl(webUri, mode: LaunchMode.externalApplication);
    }
  }

  void _showNearbyNotification(PropertyModel property) {
    _notificationEntry?.remove();
    final overlay = Overlay.of(context);

    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final l10n = AppLocalizations.of(context)!;

    _notificationEntry = OverlayEntry(
      builder: (context) {
        return Positioned(
          top: MediaQuery.of(context).padding.top + 16,
          left: 16,
          right: 16,
          child: Material(
            color: Colors.transparent,
            child: Container(
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
              decoration: BoxDecoration(
                color: colorScheme.surface,
                borderRadius: BorderRadius.circular(16),
                border: Border.all(color: colorScheme.primary),
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withOpacity(0.35),
                    blurRadius: 16,
                    offset: const Offset(0, 8),
                  ),
                ],
              ),
              child: Row(
                children: [
                  Icon(Icons.near_me, color: colorScheme.primary),
                  const SizedBox(width: 12),
                  Expanded(
                    child: Text(
                      l10n.nearbyListing,
                      style: theme.textTheme.bodyMedium?.copyWith(
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                  ),
                  TextButton(
                    onPressed: () {
                      _notificationEntry?.remove();
                      _notificationEntry = null;
                      _openDetailsSheet(property);
                    },
                    child: Text(
                      l10n.view,
                      style: theme.textTheme.bodyMedium?.copyWith(
                        color: colorScheme.primary,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
        );
      },
    );

    overlay.insert(_notificationEntry!);
    Future.delayed(const Duration(seconds: 6), () {
      _notificationEntry?.remove();
      _notificationEntry = null;
    });
  }
}
class _MapRenderer extends StatelessWidget {
  final CameraPosition initialCamera;
  final MapType mapType;
  final bool trafficEnabled;
  final bool buildingsEnabled;
  final bool myLocationEnabled;
  final Set<Marker> markers;
  final void Function(GoogleMapController) onMapCreated;
  final ValueChanged<CameraPosition> onCameraMove;
  final VoidCallback onCameraIdle;

  const _MapRenderer({
    required this.initialCamera,
    required this.mapType,
    required this.trafficEnabled,
    required this.buildingsEnabled,
    required this.myLocationEnabled,
    required this.markers,
    required this.onMapCreated,
    required this.onCameraMove,
    required this.onCameraIdle,
  });

  @override
  Widget build(BuildContext context) {
    return GoogleMap(
      initialCameraPosition: initialCamera,
      onMapCreated: onMapCreated,
      mapType: mapType,
      trafficEnabled: trafficEnabled,
      buildingsEnabled: buildingsEnabled,
      indoorViewEnabled: true,
      compassEnabled: true,
      myLocationEnabled: myLocationEnabled,
      myLocationButtonEnabled: false,
      liteModeEnabled: false,
      style: null,
      markers: markers,
      onCameraMove: onCameraMove,
      onCameraIdle: onCameraIdle,
    );
  }
}

class _MapOverlays extends StatelessWidget {
  final _MapScreenController controller;
  final MapProvider mapProvider;
  final PropertyProvider propertyProvider;
  final TrialProvider trialProvider;
  final VoidCallback onSearch;
  final VoidCallback onShowLayers;
  final VoidCallback onShowOverflowMenu;
  final VoidCallback onGoToMyLocation;
  final VoidCallback onSellHere;
  final VoidCallback onShowTrialRequired;
  final void Function(PropertyModel property) onOpenDetailsSheet;

  const _MapOverlays({
    required this.controller,
    required this.mapProvider,
    required this.propertyProvider,
    required this.trialProvider,
    required this.onSearch,
    required this.onShowLayers,
    required this.onShowOverflowMenu,
    required this.onGoToMyLocation,
    required this.onSellHere,
    required this.onShowTrialRequired,
    required this.onOpenDetailsSheet,
  });

  @override
  Widget build(BuildContext context) {
    if (!controller.mapReady) {
      return const _MapInitializingOverlay();
    }

    final l10n = AppLocalizations.of(context)!;
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final searchLabel = controller.searchLabel.isEmpty
        ? l10n.searchPlaces
        : controller.searchLabel;
    final locationEnabled = mapProvider.locationPermissionGranted;
    final mapError = mapProvider.error;
    final mapRenderError = controller.mapRenderError;
    final canAccessPremium = trialProvider.isTrialActive;
    final trialRemaining = trialProvider.trialRemaining;
    final showTrialBanner = trialProvider.isTrialExpired;

    return Stack(
      children: [
        if (mapError != null)
          Positioned(
            left: 16,
            right: 16,
            bottom: 160,
            child: SafeArea(
              child: Material(
                color: colorScheme.errorContainer,
                borderRadius: BorderRadius.circular(16),
                elevation: 2,
                child: Padding(
                  padding: const EdgeInsets.symmetric(
                    horizontal: 16,
                    vertical: 12,
                  ),
                  child: Row(
                    children: [
                      Icon(
                        Icons.error_outline,
                        color: colorScheme.onErrorContainer,
                      ),
                      const SizedBox(width: 12),
                      Expanded(
                        child: Text(
                          mapError,
                          style: theme.textTheme.bodySmall?.copyWith(
                            color: colorScheme.onErrorContainer,
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            ),
          ),
        if (mapRenderError != null)
          Positioned(
            left: 16,
            right: 16,
            bottom: 112,
            child: SafeArea(
              child: Material(
                color: colorScheme.errorContainer,
                borderRadius: BorderRadius.circular(16),
                elevation: 2,
                child: Padding(
                  padding: const EdgeInsets.symmetric(
                    horizontal: 16,
                    vertical: 12,
                  ),
                  child: Row(
                    children: [
                      Icon(
                        Icons.map_outlined,
                        color: colorScheme.onErrorContainer,
                      ),
                      const SizedBox(width: 12),
                      Expanded(
                        child: Text(
                          mapRenderError,
                          style: theme.textTheme.bodySmall?.copyWith(
                            color: colorScheme.onErrorContainer,
                          ),
                        ),
                      ),
                      TextButton(
                        onPressed: controller.retryMapLoad,
                        child: Text(
                          l10n.retry,
                          style: TextStyle(color: colorScheme.onErrorContainer),
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            ),
          ),
        if (!locationEnabled)
          Positioned(
            left: 16,
            right: 16,
            bottom: 96,
            child: SafeArea(
              child: Material(
                color: colorScheme.surface,
                borderRadius: BorderRadius.circular(16),
                elevation: 2,
                child: Padding(
                  padding: const EdgeInsets.symmetric(
                    horizontal: 16,
                    vertical: 12,
                  ),
                  child: Row(
                    children: [
                      Icon(Icons.location_off, color: colorScheme.primary),
                      const SizedBox(width: 12),
                      Expanded(
                        child: Text(
                          l10n.locationPermissionMessage,
                          style: theme.textTheme.bodySmall?.copyWith(
                            color: colorScheme.onSurface.withOpacity(0.8),
                          ),
                        ),
                      ),
                      TextButton(
                        onPressed: mapProvider.requestLocationPermission,
                        child: Text(
                          l10n.retry,
                          style: TextStyle(color: colorScheme.primary),
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            ),
          ),
        Positioned(
          top: 12,
          left: 16,
          right: 16,
          child: SafeArea(
            child: Row(
              children: [
                Expanded(
                  child: GestureDetector(
                    onTap: onSearch,
                    child: Container(
                      height: 48,
                      padding: const EdgeInsets.symmetric(horizontal: 16),
                      decoration: BoxDecoration(
                        color: colorScheme.surface,
                        borderRadius: BorderRadius.circular(24),
                        border: Border.all(color: colorScheme.outline),
                        boxShadow: [
                          BoxShadow(
                            color: Colors.black.withOpacity(0.2),
                            blurRadius: 12,
                            offset: const Offset(0, 6),
                          ),
                        ],
                      ),
                      child: Row(
                        children: [
                          Icon(Icons.search, color: colorScheme.primary),
                          const SizedBox(width: 8),
                          Expanded(
                            child: Text(
                              searchLabel,
                              maxLines: 1,
                              overflow: TextOverflow.ellipsis,
                              style: theme.textTheme.bodyMedium?.copyWith(
                                color: colorScheme.onSurface.withOpacity(0.8),
                              ),
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
                ),
                const SizedBox(width: 12),
                _RoundMapButton(
                  icon: Icons.layers_outlined,
                  onTap: onShowLayers,
                  backgroundColor: colorScheme.surface,
                  iconColor: colorScheme.onSurface,
                ),
                const SizedBox(width: 12),
                _RoundMapButton(
                  icon: Icons.more_vert,
                  onTap: onShowOverflowMenu,
                  backgroundColor: colorScheme.surface,
                  iconColor: colorScheme.onSurface,
                ),
              ],
            ),
          ),
        ),
        if (showTrialBanner)
          Positioned(
            top: 76,
            left: 16,
            right: 16,
            child: SafeArea(
              child: Container(
                padding: const EdgeInsets.symmetric(
                  horizontal: 16,
                  vertical: 10,
                ),
                decoration: BoxDecoration(
                  color: colorScheme.surface,
                  borderRadius: BorderRadius.circular(16),
                  border: Border.all(color: colorScheme.error),
                  boxShadow: [
                    BoxShadow(
                      color: Colors.black.withOpacity(0.2),
                      blurRadius: 12,
                      offset: const Offset(0, 6),
                    ),
                  ],
                ),
                child: Row(
                  children: [
                    Icon(Icons.lock, color: colorScheme.error),
                    const SizedBox(width: 8),
                    Expanded(
                      child: Text(
                        l10n.trialExpiredBanner,
                        style: theme.textTheme.bodySmall?.copyWith(
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ),
          )
        else if (trialRemaining != null)
          Positioned(
            top: 76,
            left: 16,
            right: 16,
            child: SafeArea(
              child: Container(
                padding: const EdgeInsets.symmetric(
                  horizontal: 16,
                  vertical: 8,
                ),
                decoration: BoxDecoration(
                  color: colorScheme.surface,
                  borderRadius: BorderRadius.circular(16),
                  border: Border.all(color: colorScheme.outline),
                  boxShadow: [
                    BoxShadow(
                      color: Colors.black.withOpacity(0.2),
                      blurRadius: 12,
                      offset: const Offset(0, 6),
                    ),
                  ],
                ),
                child: Row(
                  children: [
                    Icon(Icons.timer, color: colorScheme.primary),
                    const SizedBox(width: 8),
                    Expanded(
                      child: Text(
                        l10n.trialEndsIn(_formatDuration(l10n, trialRemaining)),
                        style: theme.textTheme.bodySmall?.copyWith(
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ),
        Positioned(
          right: 16,
          bottom: controller.isBottomSheetExpanded ? 290 : 112,
          child: _RoundMapButton(
            icon: Icons.my_location,
            onTap: onGoToMyLocation,
            backgroundColor: colorScheme.primary,
            iconColor: colorScheme.onPrimary,
          ),
        ),
        Positioned(
          right: 16,
          bottom: controller.isBottomSheetExpanded ? 220 : 24,
          child: FloatingActionButton.extended(
            heroTag: 'sell_here_button',
            backgroundColor: colorScheme.primary,
            foregroundColor: colorScheme.onPrimary,
            onPressed: canAccessPremium ? onSellHere : onShowTrialRequired,
            label: Text(l10n.sellHere),
            icon: const Icon(Icons.storefront),
          ),
        ),
        _buildNearbyOverlay(context),
        _buildBottomSheet(context),
      ],
    );
  }

  Widget _buildNearbyOverlay(BuildContext context) {
    if (controller.nearbyOverlay.isEmpty) {
      return const SizedBox.shrink();
    }

    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    return Positioned(
      right: 16,
      top: 132,
      child: Material(
        color: Colors.transparent,
        child: Container(
          constraints: const BoxConstraints(
            maxHeight: 220,
            maxWidth: 160,
          ),
          decoration: BoxDecoration(
            color: colorScheme.surface,
            borderRadius: BorderRadius.circular(16),
            border: Border.all(color: colorScheme.outline),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withOpacity(0.15),
                blurRadius: 12,
                offset: const Offset(0, 6),
              ),
            ],
          ),
          child: ListView.separated(
            padding: const EdgeInsets.all(8),
            shrinkWrap: true,
            itemCount: controller.nearbyOverlay.length,
            separatorBuilder: (_, _) => const SizedBox(height: 6),
            itemBuilder: (context, index) {
              final property = controller.nearbyOverlay[index];
              final imageUrl =
                  property.imageUrls.isNotEmpty ? property.imageUrls.first : null;
              return InkWell(
                onTap: () => onOpenDetailsSheet(property),
                borderRadius: BorderRadius.circular(12),
                child: Padding(
                  padding: const EdgeInsets.symmetric(vertical: 6, horizontal: 6),
                  child: Row(
                    children: [
                      CircleAvatar(
                        radius: 16,
                        backgroundColor: colorScheme.primary.withOpacity(0.15),
                        backgroundImage:
                            imageUrl != null ? NetworkImage(imageUrl) : null,
                        child: imageUrl == null
                            ? Icon(
                                Icons.near_me,
                                color: colorScheme.primary,
                                size: 16,
                              )
                            : null,
                      ),
                      const SizedBox(width: 8),
                      Expanded(
                        child: Text(
                          property.title,
                          maxLines: 1,
                          overflow: TextOverflow.ellipsis,
                          style: theme.textTheme.labelMedium?.copyWith(
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
              );
            },
          ),
        ),
      ),
    );
  }

  Widget _buildBottomSheet(BuildContext context) {
    final properties = propertyProvider.nearbyProperties;
    final colorScheme = Theme.of(context).colorScheme;
    final double sheetHeight = MediaQuery.of(context).size.height * 0.30;

    return AnimatedPositioned(
      duration: const Duration(milliseconds: 300),
      curve: Curves.easeInOut,
      bottom: controller.isBottomSheetExpanded ? 0 : -sheetHeight,
      left: 0,
      right: 0,
      child: Container(
        height: sheetHeight,
        decoration: BoxDecoration(
          color: colorScheme.surface,
          borderRadius: const BorderRadius.vertical(top: Radius.circular(24)),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.35),
              blurRadius: 20,
            ),
          ],
        ),
        child: controller.selectedProperty != null
            ? _selectedPropertyCard(context, controller.selectedProperty!)
            : _propertiesList(context, properties),
      ),
    );
  }

  Widget _selectedPropertyCard(BuildContext context, PropertyModel property) {
    final l10n = AppLocalizations.of(context)!;
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    return Padding(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            property.title,
            maxLines: 2,
            overflow: TextOverflow.ellipsis,
            style: theme.textTheme.titleMedium?.copyWith(
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            property.address.isNotEmpty ? property.address : l10n.locationNotSet,
            maxLines: 2,
            overflow: TextOverflow.ellipsis,
            style: theme.textTheme.bodySmall?.copyWith(
              color: colorScheme.onSurface.withOpacity(0.7),
            ),
          ),
          const Spacer(),
          SizedBox(
            width: double.infinity,
            child: ElevatedButton(
              onPressed: () => onOpenDetailsSheet(property),
              child: Text(l10n.viewDetails),
            ),
          ),
        ],
      ),
    );
  }

  Widget _propertiesList(BuildContext context, List<PropertyModel> properties) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final l10n = AppLocalizations.of(context)!;

    return ListView.builder(
      padding: const EdgeInsets.all(16),
      scrollDirection: Axis.horizontal,
      itemCount: properties.length,
      itemBuilder: (context, index) {
        final property = properties[index];

        return GestureDetector(
          onTap: () => controller.selectProperty(property),
          child: Container(
            width: 220,
            margin: const EdgeInsets.only(right: 12),
            child: Card(
              elevation: 4,
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(16),
              ),
              color: colorScheme.surface,
              child: Padding(
                padding: const EdgeInsets.all(12),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      property.title,
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                      style: theme.textTheme.titleSmall?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 8),
                    Text(
                      property.address.isNotEmpty
                          ? property.address
                          : l10n.locationNotSet,
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                      style: theme.textTheme.bodySmall?.copyWith(
                        color: colorScheme.onSurface.withOpacity(0.7),
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ),
        );
      },
    );
  }
}

class _MapInitializingOverlay extends StatelessWidget {
  const _MapInitializingOverlay();

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    return Material(
      color: Colors.transparent,
      child: Center(
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12),
          decoration: BoxDecoration(
            color: colorScheme.surface,
            borderRadius: BorderRadius.circular(16),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withOpacity(0.2),
                blurRadius: 12,
                offset: const Offset(0, 6),
              ),
            ],
          ),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              const SizedBox(
                height: 22,
                width: 22,
                child: CircularProgressIndicator(strokeWidth: 2),
              ),
              const SizedBox(width: 12),
              Text(
                AppLocalizations.of(context)?.loading ?? 'Loading map...',
              ),
            ],
          ),
        ),
      ),
    );
  }
}
class _MapScreenController extends ChangeNotifier {
  _MapScreenController({
    required this.mapProvider,
    required this.propertyProvider,
    required this.userProfileService,
    required this.onNearbyNotification,
    required this.isMounted,
  });

  final MapProvider mapProvider;
  final PropertyProvider propertyProvider;
  final UserProfileService userProfileService;
  final void Function(PropertyModel property)? onNearbyNotification;
  final bool Function() isMounted;

  final Map<String, DateTime> _lastNotified = {};
  final bool _followUserLocation = true;

  GoogleMapController? _mapController;
  bool _mapDisposed = false;
  bool _mapReady = false;
  bool _isUserInteracting = false;
  bool _isBottomSheetExpanded = false;
  bool _didInitialCameraMove = false;
  PropertyModel? _selectedProperty;
  LatLng? _lastLoadedLocation;
  Timer? _nearbyTimer;
  Timer? _cameraDebounce;
  Timer? _nearbyOverlayDebounce;
  Timer? _mapLoadCheckTimer;
  Marker? _searchMarker;
  String _searchLabel = '';
  Set<Marker> _propertyMarkers = {};
  List<PropertyModel> _nearbyOverlay = [];
  int _markerBuildToken = 0;
  bool _checkingPlayServices = true;
  bool _playServicesAvailable = true;
  String? _playServicesError;
  bool _canUpdatePlayServices = false;
  String? _mapRenderError;
  bool _disposed = false;

  GoogleMapController? get mapController => _mapController;
  bool get mapReady => _mapReady;
  bool get isBottomSheetExpanded => _isBottomSheetExpanded;
  PropertyModel? get selectedProperty => _selectedProperty;
  List<PropertyModel> get nearbyOverlay => List.unmodifiable(_nearbyOverlay);
  String get searchLabel => _searchLabel;
  bool get checkingPlayServices => _checkingPlayServices;
  bool get playServicesAvailable => _playServicesAvailable;
  String? get playServicesError => _playServicesError;
  bool get canUpdatePlayServices => _canUpdatePlayServices;
  String? get mapRenderError => _mapRenderError;
  Set<Marker> get markers => {
        ..._propertyMarkers,
        if (_searchMarker != null) _searchMarker!,
      };

  bool _canUseMapController() {
    return isMounted() && !_mapDisposed && _mapController != null;
  }

  Future<T?> _withMapController<T>(
    Future<T> Function(GoogleMapController controller) action,
  ) async {
    if (!_canUseMapController()) return null;
    final controller = _mapController;
    if (controller == null) return null;
    try {
      return await action(controller);
    } catch (_) {
      return null;
    }
  }

  Future<void> safeAnimateCamera(CameraUpdate update) async {
    await _withMapController((controller) => controller.animateCamera(update));
  }

  void attachListeners() {
    mapProvider.addListener(_handleLocationUpdate);
    propertyProvider.addListener(_handlePropertiesUpdate);
  }

  void _detachListeners() {
    mapProvider.removeListener(_handleLocationUpdate);
    propertyProvider.removeListener(_handlePropertiesUpdate);
  }

  void startNearbyTimer() {
    _nearbyTimer?.cancel();
    _nearbyTimer = Timer.periodic(const Duration(seconds: 30), (_) {
      _checkNearbyListings();
    });
  }

  void refreshFromProviders() {
    _handleLocationUpdate();
    _handlePropertiesUpdate();
  }

  Future<void> checkPlayServicesAvailability() async {
    if (GoogleMapsConfig.apiKey.trim().isEmpty) {
      _updateSafely(() {
        _checkingPlayServices = false;
        _playServicesAvailable = false;
        _playServicesError = 'Google Maps API key is not configured.\n\n'
            'To fix this, set the API key in lib/core/config/google_maps_config.dart.\n'
            'Additionally, configure it in:\n'
            '- Android: AndroidManifest.xml <meta-data android:name="com.google.android.geo.API_KEY" android:value="YOUR_KEY"/>\n'
            '- iOS: AppDelegate.swift GMSServices.provideAPIKey("YOUR_KEY")\n'
            '- Web: index.html <script src="https://maps.googleapis.com/maps/api/js?key=YOUR_KEY"></script>';
        _canUpdatePlayServices = false;
      });
      return;
    }

    if (!Platform.isAndroid) {
      _updateSafely(() {
        _checkingPlayServices = false;
        _playServicesAvailable = true;
        _playServicesError = null;
        _canUpdatePlayServices = false;
      });
      return;
    }

    try {
      final availability = await GoogleApiAvailability.instance
          .checkGooglePlayServicesAvailability();
      _updateSafely(() {
        _checkingPlayServices = false;
        _playServicesAvailable =
            availability == GooglePlayServicesAvailability.success;
        _canUpdatePlayServices = !_playServicesAvailable;
        _playServicesError = _playServicesAvailable
            ? null
            : _describePlayServicesIssue(availability);
      });
    } catch (e) {
      _updateSafely(() {
        _checkingPlayServices = false;
        _playServicesAvailable = false;
        _canUpdatePlayServices = false;
        _playServicesError = 'Google Play Services check failed: $e';
      });
    }
  }

  Future<void> onMapCreated(GoogleMapController controller) async {
    if (_mapDisposed || !isMounted()) return;
    _mapController = controller;
    _mapReady = true;
    _updateSafely(() {
      _mapRenderError = null;
    });
    _notifySafely();
    _scheduleMapLoadCheck();

    final current = mapProvider.currentLocation;
    if (current != null) {
      await safeAnimateCamera(
        CameraUpdate.newCameraPosition(
          CameraPosition(
            target: current,
            zoom: GoogleMapsConfig.initialZoom,
          ),
        ),
      );
      _didInitialCameraMove = true;
    }

    _handlePropertiesUpdate();
    _loadPropertiesForVisibleRegion();
  }

  void retryMapLoad() {
    if (_disposed) return;
    _updateSafely(() {
      _mapRenderError = null;
    });
    _scheduleMapLoadCheck(delay: const Duration(milliseconds: 700));
    final current = mapProvider.currentLocation;
    if (current != null) {
      safeAnimateCamera(
        CameraUpdate.newCameraPosition(
          CameraPosition(
            target: current,
            zoom: GoogleMapsConfig.initialZoom,
          ),
        ),
      );
    }
  }

  void onCameraMove(CameraPosition position) {
    _isUserInteracting = true;
    mapProvider.updateCameraPosition(position);
    _scheduleCameraQuery();
  }

  void onCameraIdle() {
    _isUserInteracting = false;
  }

  void selectProperty(PropertyModel property) {
    _updateSafely(() {
      _selectedProperty = property;
      _isBottomSheetExpanded = true;
    });
  }

  void setSearchLabel(String label) {
    _updateSafely(() {
      _searchLabel = label;
    });
  }

  Future<void> updateSearchMarker(LatLng location, String label) async {
    final icon = await MapMarkerWidget.buildMarkerIcon(
      cacheKey: 'search_$label',
      imageUrl: null,
    );
    _updateSafely(() {
      _searchMarker = Marker(
        markerId: const MarkerId('search'),
        position: location,
        infoWindow: InfoWindow(title: label),
        icon: icon,
      );
    });
  }

  void _handlePropertiesUpdate() {
    if (_disposed) return;
    final properties = propertyProvider.nearbyProperties;
    _buildPropertyMarkers(properties);
    _scheduleNearbyOverlayUpdate();
  }

  Future<void> _buildPropertyMarkers(List<PropertyModel> properties) async {
    final buildToken = ++_markerBuildToken;
    final markers = await Future.wait(
      properties.map((property) async {
        final imageUrl = await _resolveMarkerImage(property);
        final icon = await MapMarkerWidget.buildMarkerIcon(
          cacheKey: '${property.id}_${imageUrl ?? 'none'}',
          imageUrl: imageUrl,
        );
        return Marker(
          markerId: MarkerId(property.id),
          position: LatLng(
            property.location.latitude,
            property.location.longitude,
          ),
          onTap: () => selectProperty(property),
          icon: icon,
        );
      }),
    );

    if (_disposed || buildToken != _markerBuildToken) return;
    _updateSafely(() {
      _propertyMarkers = markers.toSet();
    });
  }

  Future<String?> _resolveMarkerImage(PropertyModel property) async {
    final ownerId = property.sellerId;
    String? ownerPhoto;
    if (ownerId.isNotEmpty) {
      ownerPhoto = await userProfileService.getPhotoUrl(ownerId);
    }
    if (ownerPhoto != null && ownerPhoto.isNotEmpty) {
      return ownerPhoto;
    }
    if (property.imageUrls.isNotEmpty) {
      return property.imageUrls.first;
    }
    return null;
  }

  void _handleLocationUpdate() {
    if (_disposed) return;

    final currentLocation = mapProvider.currentLocation;
    if (currentLocation == null) return;

    final distance = _lastLoadedLocation == null
        ? double.infinity
        : _distanceBetween(_lastLoadedLocation!, currentLocation);

    if (!_didInitialCameraMove) {
      safeAnimateCamera(
        CameraUpdate.newCameraPosition(
          CameraPosition(
            target: currentLocation,
            zoom: GoogleMapsConfig.initialZoom,
          ),
        ),
      );
      _didInitialCameraMove = true;
    }

    if (_followUserLocation && !_isUserInteracting && distance > 5) {
      safeAnimateCamera(
        CameraUpdate.newCameraPosition(
          CameraPosition(
            target: currentLocation,
            zoom: mapProvider.cameraPosition?.zoom ??
                GoogleMapsConfig.initialZoom,
          ),
        ),
      );
    }

    if (_lastLoadedLocation == null || distance > 30) {
      _lastLoadedLocation = currentLocation;
      propertyProvider.loadNearbyProperties(currentLocation);
    }

    _scheduleNearbyOverlayUpdate();
  }

  double _distanceBetween(LatLng a, LatLng b) {
    return Geolocator.distanceBetween(
      a.latitude,
      a.longitude,
      b.latitude,
      b.longitude,
    );
  }

  void _scheduleCameraQuery() {
    _cameraDebounce?.cancel();
    _cameraDebounce = Timer(
      const Duration(milliseconds: 450),
      _loadPropertiesForVisibleRegion,
    );
  }

  Future<void> _loadPropertiesForVisibleRegion() async {
    try {
      final bounds =
          await _withMapController((controller) => controller.getVisibleRegion());
      if (bounds == null) return;
      if (_disposed) return;
      await propertyProvider.loadPropertiesInBounds(bounds);
    } catch (_) {
      // Ignore map errors while the camera is still initializing.
    }
  }

  void _scheduleNearbyOverlayUpdate() {
    _nearbyOverlayDebounce?.cancel();
    _nearbyOverlayDebounce = Timer(
      const Duration(milliseconds: 400),
      _updateNearbyOverlay,
    );
  }

  void _scheduleMapLoadCheck({Duration delay = const Duration(seconds: 3)}) {
    _mapLoadCheckTimer?.cancel();
    _mapLoadCheckTimer = Timer(delay, _verifyMapTiles);
  }

  Future<void> _verifyMapTiles() async {
    if (_disposed) return;
    final bounds =
        await _withMapController((controller) => controller.getVisibleRegion());
    if (_disposed) return;
    if (bounds == null) {
      _updateSafely(() {
        _mapRenderError =
            'Map tiles failed to load. Check your connection or API key, then retry.';
      });
      return;
    }
    if (_mapRenderError != null) {
      _updateSafely(() {
        _mapRenderError = null;
      });
    }
  }

  void _updateNearbyOverlay() {
    if (_disposed) return;
    final currentLocation = mapProvider.currentLocation;
    final properties = propertyProvider.nearbyProperties;
    if (currentLocation == null) {
      if (_nearbyOverlay.isNotEmpty) {
        _updateSafely(() => _nearbyOverlay = []);
      }
      return;
    }

    final withinRadius = properties
        .where(
          (property) =>
              _distanceBetween(currentLocation, property.location) <= 40,
        )
        .toList();

    final newIds = withinRadius.map((p) => p.id).join(',');
    final oldIds = _nearbyOverlay.map((p) => p.id).join(',');
    if (newIds == oldIds) return;

    _updateSafely(() {
      _nearbyOverlay = withinRadius;
    });
  }

  void _checkNearbyListings() {
    if (_disposed) return;

    final currentLocation = mapProvider.currentLocation;
    if (currentLocation == null) return;

    for (final property in propertyProvider.nearbyProperties) {
      final distance = _distanceBetween(
        currentLocation,
        property.location,
      );
      if (distance > 10) {
        continue;
      }

      final lastTime = _lastNotified[property.id];
      final now = DateTime.now();
      if (lastTime != null &&
          now.difference(lastTime) < const Duration(minutes: 4)) {
        continue;
      }

      _lastNotified[property.id] = now;
      onNearbyNotification?.call(property);
      break;
    }
  }

  String _describePlayServicesIssue(
    GooglePlayServicesAvailability availability,
  ) {
    switch (availability) {
      case GooglePlayServicesAvailability.serviceMissing:
        return 'Google Play Services is missing on this device.';
      case GooglePlayServicesAvailability.serviceUpdating:
        return 'Google Play Services is updating. Please try again shortly.';
      case GooglePlayServicesAvailability.serviceVersionUpdateRequired:
        return 'Google Play Services needs an update to show the map.';
      case GooglePlayServicesAvailability.serviceDisabled:
        return 'Google Play Services is disabled. Please enable it.';
      case GooglePlayServicesAvailability.serviceInvalid:
        return 'Google Play Services is invalid on this device.';
      case GooglePlayServicesAvailability.success:
        return '';
    }
    return 'Google Play Services status is unknown.';
  }

  void _updateSafely(VoidCallback fn) {
    if (_disposed) return;
    fn();
    notifyListeners();
  }

  void _notifySafely() {
    if (_disposed) return;
    notifyListeners();
  }

  @override
  void dispose() {
    _disposed = true;
    _mapDisposed = true;
    _mapController = null;
    _detachListeners();
    _nearbyTimer?.cancel();
    _cameraDebounce?.cancel();
    _nearbyOverlayDebounce?.cancel();
    _mapLoadCheckTimer?.cancel();
    super.dispose();
  }
}
class _PlaceSuggestion {
  final String description;
  final String placeId;

  const _PlaceSuggestion({
    required this.description,
    required this.placeId,
  });
}

class _RoundMapButton extends StatelessWidget {
  final IconData icon;
  final VoidCallback onTap;
  final Color backgroundColor;
  final Color iconColor;

  const _RoundMapButton({
    required this.icon,
    required this.onTap,
    required this.backgroundColor,
    required this.iconColor,
  });

  @override
  Widget build(BuildContext context) {
    return Material(
      color: backgroundColor,
      shape: const CircleBorder(),
      elevation: 6,
      child: InkWell(
        customBorder: const CircleBorder(),
        onTap: onTap,
        child: SizedBox(
          height: 44,
          width: 44,
          child: Icon(icon, color: iconColor),
        ),
      ),
    );
  }
}

String _formatDuration(AppLocalizations l10n, Duration duration) {
  final totalDays = duration.inDays;
  if (totalDays >= 1) {
    return l10n.remainingDays(totalDays);
  }
  final hours = duration.inHours;
  if (hours >= 1) {
    return l10n.remainingHours(hours);
  }
  final minutes = duration.inMinutes;
  return l10n.remainingMinutes(minutes);
}

class SellHereSheet extends StatefulWidget {
  final LatLng location;
  final String address;

  const SellHereSheet({
    super.key,
    required this.location,
    required this.address,
  });

  @override
  State<SellHereSheet> createState() => _SellHereSheetState();
}

class _SellHereSheetState extends State<SellHereSheet> {
  final _formKey = GlobalKey<FormState>();
  final _titleController = TextEditingController();
  final _descriptionController = TextEditingController();
  final _priceController = TextEditingController();
  final _phoneController = TextEditingController();
  final ImagePicker _imagePicker = ImagePicker();
  final List<XFile> _selectedImages = [];
  PropertyType _selectedType = PropertyType.house;
  bool _isSubmitting = false;

  @override
  void initState() {
    super.initState();
    final authProvider = context.read<AuthProvider>();
    _phoneController.text = authProvider.user?.phoneNumber ?? '';
  }

  Future<void> _pickImages() async {
    try {
      final images = await _imagePicker.pickMultiImage(
        imageQuality: 85,
        maxWidth: 1600,
      );
      if (!mounted || images.isEmpty) return;
      setState(() {
        _selectedImages.addAll(images);
      });
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Image selection failed')),
      );
    }
  }

  void _removeImage(int index) {
    setState(() {
      _selectedImages.removeAt(index);
    });
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final viewInsets = MediaQuery.of(context).viewInsets;

    return SafeArea(
      child: SingleChildScrollView(
        padding: EdgeInsets.only(
          left: 20,
          right: 20,
          top: 16,
          bottom: 16 + viewInsets.bottom,
        ),
        child: Form(
          key: _formKey,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Center(
                child: Container(
                  width: 44,
                  height: 4,
                  decoration: BoxDecoration(
                    color: colorScheme.onSurface.withOpacity(0.3),
                    borderRadius: BorderRadius.circular(2),
                  ),
                ),
              ),
              const SizedBox(height: 16),
              Text(
                l10n.sellHere,
                style: theme.textTheme.titleLarge?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 8),
              Text(
                widget.address,
                maxLines: 2,
                overflow: TextOverflow.ellipsis,
                style: theme.textTheme.bodySmall?.copyWith(
                  color: colorScheme.onSurface.withOpacity(0.7),
                ),
              ),
              const SizedBox(height: 16),
              DropdownButtonFormField<PropertyType>(
                value: _selectedType,
                onChanged: (value) {
                  if (value == null) return;
                  setState(() => _selectedType = value);
                },
                items: PropertyType.values.map((type) {
                  return DropdownMenuItem<PropertyType>(
                    value: type,
                    child: Text(type.displayName),
                  );
                }).toList(),
                decoration: InputDecoration(
                  labelText: l10n.propertyType,
                ),
              ),
              const SizedBox(height: 12),
              TextFormField(
                controller: _titleController,
                decoration: InputDecoration(labelText: l10n.title),
                validator: (value) => value == null || value.trim().isEmpty
                    ? l10n.titleRequired
                    : null,
              ),
              const SizedBox(height: 12),
              TextFormField(
                controller: _priceController,
                decoration: InputDecoration(labelText: l10n.priceOptional),
                keyboardType: TextInputType.number,
                validator: (value) {
                  if (value == null || value.trim().isEmpty) return null;
                  return double.tryParse(value) == null ? l10n.invalidPrice : null;
                },
              ),
              const SizedBox(height: 12),
              TextFormField(
                controller: _phoneController,
                decoration: InputDecoration(labelText: l10n.phoneNumber),
                keyboardType: TextInputType.phone,
                validator: (value) => value == null || value.trim().isEmpty
                    ? l10n.phoneRequired
                    : null,
              ),
              const SizedBox(height: 12),
              TextFormField(
                controller: _descriptionController,
                decoration: InputDecoration(labelText: l10n.description),
                maxLines: 3,
                validator: (value) => value == null || value.trim().isEmpty
                    ? l10n.descriptionRequired
                    : null,
              ),
              const SizedBox(height: 20),
              Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'Photos',
                    style: theme.textTheme.titleSmall?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 8),
                  SizedBox(
                    width: double.infinity,
                    child: OutlinedButton.icon(
                      onPressed: _pickImages,
                      icon: const Icon(Icons.photo_library_outlined),
                      label: Text(
                        _selectedImages.isEmpty
                            ? 'Add photos (required)'
                            : 'Add more photos',
                      ),
                    ),
                  ),
                  if (_selectedImages.isNotEmpty) ...[
                    const SizedBox(height: 12),
                    SizedBox(
                      height: 88,
                      child: ListView.separated(
                        scrollDirection: Axis.horizontal,
                        itemCount: _selectedImages.length,
                        separatorBuilder: (_, _) => const SizedBox(width: 8),
                        itemBuilder: (context, index) {
                          final image = _selectedImages[index];
                          return Stack(
                            children: [
                              ClipRRect(
                                borderRadius: BorderRadius.circular(12),
                                child: _SheetImagePreview(file: image),
                              ),
                              Positioned(
                                top: 4,
                                right: 4,
                                child: InkWell(
                                  onTap: () => _removeImage(index),
                                  child: Container(
                                    padding: const EdgeInsets.all(4),
                                    decoration: BoxDecoration(
                                      color: Colors.black.withOpacity(0.6),
                                      shape: BoxShape.circle,
                                    ),
                                    child: const Icon(
                                      Icons.close,
                                      size: 14,
                                      color: Colors.white,
                                    ),
                                  ),
                                ),
                              ),
                            ],
                          );
                        },
                      ),
                    ),
                  ],
                  if (_selectedImages.isEmpty) ...[
                    const SizedBox(height: 8),
                    Text(
                      'At least one image is required to publish.',
                      style: theme.textTheme.bodySmall,
                    ),
                  ],
                ],
              ),
              const SizedBox(height: 20),
              SizedBox(
                width: double.infinity,
                child: ElevatedButton(
                  onPressed: _isSubmitting ? null : _submit,
                  child: Text(l10n.publishListing),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Future<void> _submit() async {
    if (!_formKey.currentState!.validate()) return;
    if (_selectedImages.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('At least one photo is required')),
      );
      return;
    }

    if (_isSubmitting) return;
    setState(() {
      _isSubmitting = true;
    });

    final statusNotifier = ValueNotifier<String>('Uploading images...');
    _showProgressDialog(statusNotifier);

    final authProvider = context.read<AuthProvider>();
    final propertyProvider = context.read<PropertyProvider>();

    try {
      final imageBytes = <Uint8List>[];
      for (final image in _selectedImages) {
        imageBytes.add(await image.readAsBytes());
      }

      final imgbb = ImgbbService();
      final imageUrls = await imgbb.uploadImages(
        images: imageBytes,
        onProgress: (uploaded, total) {
          statusNotifier.value =
              'Uploading images... (${uploaded + 1}/$total)';
        },
      );

      statusNotifier.value = 'Saving listing...';

      final price = double.tryParse(_priceController.text.trim()) ?? 0;
      final property = PropertyModel(
        id: '',
        title: _titleController.text.trim(),
        description: _descriptionController.text.trim(),
        price: price,
        type: _selectedType,
        bedrooms: 0,
        bathrooms: 0,
        squareFeet: 0,
        address: widget.address,
        location: widget.location,
        sellerName: authProvider.user?.displayName ?? 'Owner',
        sellerPhone: _phoneController.text.trim(),
        sellerId: authProvider.user?.uid ?? '',
        imageUrls: imageUrls,
        listedAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );

      await propertyProvider.addProperty(property);
      if (!mounted) return;
      Navigator.of(context).pop();
      Navigator.pop(context);
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(AppLocalizations.of(context)!.listingAdded)),
      );
    } catch (e) {
      if (!mounted) return;
      Navigator.of(context).pop();
      final retry = await _showPublishErrorDialog(
        AppLocalizations.of(context)!.listingAddFailed,
        e.toString(),
      );
      if (!mounted) return;
      if (retry) {
        setState(() {
          _isSubmitting = false;
        });
        await _submit();
        return;
      }
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('${AppLocalizations.of(context)!.listingAddFailed} $e'),
        ),
      );
    } finally {
      if (mounted) {
        setState(() {
          _isSubmitting = false;
        });
      }
    }
  }

  Future<void> _showProgressDialog(ValueNotifier<String> statusNotifier) async {
    if (!mounted) return;
    await showDialog<void>(
      context: context,
      barrierDismissible: false,
      builder: (context) {
        return ValueListenableBuilder<String>(
          valueListenable: statusNotifier,
          builder: (context, value, _) {
            return AlertDialog(
              content: Row(
                children: [
                  const SizedBox(
                    height: 28,
                    width: 28,
                    child: CircularProgressIndicator(),
                  ),
                  const SizedBox(width: 16),
                  Expanded(child: Text(value)),
                ],
              ),
            );
          },
        );
      },
    );
  }

  Future<bool> _showPublishErrorDialog(String title, String details) async {
    if (!mounted) return false;
    final result = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(title),
        content: Text(details),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context, true),
            child: const Text('Retry'),
          ),
        ],
      ),
    );
    return result ?? false;
  }

  @override
  void dispose() {
    _titleController.dispose();
    _descriptionController.dispose();
    _priceController.dispose();
    _phoneController.dispose();
    super.dispose();
  }
}

class _SheetImagePreview extends StatelessWidget {
  final XFile file;

  const _SheetImagePreview({
    required this.file,
  });

  @override
  Widget build(BuildContext context) {
    const size = 88.0;
    if (kIsWeb) {
      return FutureBuilder<Uint8List>(
        future: file.readAsBytes(),
        builder: (context, snapshot) {
          final bytes = snapshot.data;
          if (bytes == null) {
            return Container(
              width: size,
              height: size,
              color: Theme.of(context).colorScheme.surfaceContainerHighest,
              alignment: Alignment.center,
              child: const SizedBox(
                height: 20,
                width: 20,
                child: CircularProgressIndicator(strokeWidth: 2),
              ),
            );
          }
          return Image.memory(
            bytes,
            width: size,
            height: size,
            fit: BoxFit.cover,
          );
        },
      );
    }
    return Image.file(
      File(file.path),
      width: size,
      height: size,
      fit: BoxFit.cover,
    );
  }
}
